# Краткое описание паттернов. Выведено в ходе наблюдения кода самостоятельно

## Поведенческие паттерны
1. **Цепочка обязанностей.** 
Создаем объект обработчика с методом вызова обработки `handle` в котором определяется как мы обрабатываем 
объекты. Делаем последовательные вызовы `handle` с параметрами-объектами из цепочки. 

2. **Команда.** 
Реализуется созданием объекта, в котором имеется однообразный вызов метода `execute`. При желании в этот объект можно 
делать инъекции в конструкторе, по отношению к чему выполняется команда и куда будут складываться результаты. 

3. **Итератор.** 
Создаем объект, содержащий данные в виде массива, списка. В этом объекте имеются методы для перехода к следущему или 
предыдущему элементу списка, определения существующей позиции.

4. **Посредник.**
Создаем объект, содержащий и управляющий вложенными объектами. При этом во вложенных объектах могут предусматриваться 
методы, связывающие друг с другом. Но управление происходит только в объекте-посреднике.

5. **Снимок.**
Создаем объект, который содержит все данные базового объекта, но не содержит логику. Управление объектом-снимком происходит
из базового объекта.

6. **Null-объект.**
    - Цель: Использование с целью замены проверок существования объекта на объект с пустым телом реализации
    - Реализация: Создается объект с пустой реализацией но с тем же интерфейсом. Действия с данным объектом происходят также как с обычными,
просто они не приводят к результатам.

7. **Наблюдатель.**
     - Цель: Выделить отношения основного и зависимого элемента
     - Реализация: Создаются 2 объекта один из которых наблюдатель, другой - обычный объект. Обычный объект содержит список объектов-наблюдателей и
и при каких-то изменениях в объекте выполняются действия над наблюдателями в виде использований методов наблюдателя.

9. **Спецификация**
    - Цель: Описать требования к бизнес-объектам и затем использовать их. Описать, что и как нужно сделать
    - Реализация: Создается интерфейс объекта. На этой основе создаются объектыс такой же сигнатурой функций как в интерфейсе. 

10. **Состояние**
     - Цель: Позволять менять объектам поведение, когда меняется их статус
     - Реализация: Создается интерфейс состояния с методами для замены самого себя на объекты состояний для контекста самого объекта.
Каждый объект состояния знает о предыдущих и последущем соседнем состоянии в контексте.

11. **Стратегия**
    - Цель: Выбор алгоритма во время работы программы. 
    - Реализация:
        - Создается интерфейс с методом-коллбэком. На этой основе создаются объекты, реализующие коллбэк и используемые в контексте.
Данные объекты называются стратегиями.
        - Либо просто создается объект с алгоритмом и используется другими объектами

12. **Шаблонный метод** 
    - Цель использования: Удобный каркас, в который наследники могут подставить свои реализации
    - Реализация: Объявлем классы, подклассы, переопределяя методы.

13. **Визитер**
    - Цель: Разделить сущности от алгоритмов визитера. При этом сущности сами будут выбирать и использовать алгоритм
    - Реализация: Реализуется объект-визитер, в котором описаны методы. Визитер сам не выбирает какой метод запускать. Объект использующий
визитер получает визитера в параметрах и запускает один из его методов. (Визитер много что умеет, но он бесправный. 
Когда и что запускать определяет объект использующий визитера)